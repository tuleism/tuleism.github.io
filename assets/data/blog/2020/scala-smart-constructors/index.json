{"hash":"25a5d663bc74a8a307f4df8ab380b824472878c6","data":{"metadata":{"siteName":"Random.nextBlog","siteUrl":"https://tuleism.github.io","siteDescription":"Tech Blog on Scala, Programming, Data, Search and Distributed Systems"},"doc":{"title":"Smart Constructors in Scala","slug":"scala-smart-constructors","path":"/blog/2020/scala-smart-constructors/","date":"15 Aug 2020","publishedTime":"2020-08-15","timeToRead":5,"content":"<h2 id=\"introduction\"><a href=\"#introduction\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Introduction</h2>\n<p>Sometimes, we need guarantees about the values in our program beyond what can be accomplished with the usual type system checks.\nTake for example an <code class=\"language-inline-text\">Email</code> type, which contains an email address:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Email<span class=\"token punctuation\">(</span>address<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The problem with <code class=\"language-inline-text\">Email</code> is that <code class=\"language-inline-text\">address</code> can contain <strong>any</strong> value of type <code class=\"language-inline-text\">String</code>, even if they are not valid email addresses.\nDue to that, code that uses <code class=\"language-inline-text\">Email</code> cannot assume that it's always a valid email address. Thus, we want to:</p>\n<ol>\n<li>Constrain the set of possible value for <code class=\"language-inline-text\">address</code> to be the set of valid email addresses.</li>\n<li>Make sure every instance of <code class=\"language-inline-text\">Email</code> satisfies this constraint. In other words, every <code class=\"language-inline-text\">Email</code> instance contains a valid email address.</li>\n</ol>\n<p>Smart Constructors is one solution for this: instead of normal constructors, we <strong>force</strong> construction through\n\"smart\" functions that only return <code class=\"language-inline-text\">Email</code> instances when the input passes validation.</p>\n<p>In our case, we can use a function that returns <code class=\"language-inline-text\">Option[Email</code>, <code class=\"language-inline-text\">Either[Error, Email]</code>, etc depends on the validation\nresult. For demonstration, I use a very simple regex:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n  NaiveEmailRegex<span class=\"token punctuation\">.</span>findFirstIn<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span>_ <span class=\"token operator\">==</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>_ <span class=\"token keyword\">=></span> <span class=\"token keyword\">new</span> Email<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Currently, I'm aware of 3 ways to implement Smart Constructors in Scala.</p>\n<h2 id=\"the-straightforward-one-sealed-trait\"><a href=\"#the-straightforward-one-sealed-trait\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Straightforward One: <code class=\"language-inline-text\">sealed trait</code></h2>\n<p>Using <code class=\"language-inline-text\">trait</code>, it is very straightforward to implement:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">trait</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">object</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    NaiveEmailRegex<span class=\"token punctuation\">.</span>findFirstIn<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span>_ <span class=\"token operator\">==</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span> _ <span class=\"token keyword\">=></span>\n      <span class=\"token keyword\">new</span> Email <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">def</span> value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span> <span class=\"token operator\">=</span> v\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>With <code class=\"language-inline-text\">sealed</code>, we disallow attempts to <code class=\"language-inline-text\">extends Email</code> from outside of this source file.</li>\n<li><code class=\"language-inline-text\">Email.fromString</code> is the only way to construct an <code class=\"language-inline-text\">Email</code> from outside of this source file.</li>\n</ul>\n<h2 id=\"the-confusing-one-final-case-class-private\"><a href=\"#the-confusing-one-final-case-class-private\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Confusing One: <code class=\"language-inline-text\">final case class private</code></h2>\n<p>When it comes to modeling data, especially those that are immutable, case classes is the method of choice for Scala.\nCompared to traits, case classes come with many <a href=\"https://docs.scala-lang.org/overviews/scala-book/case-classes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">useful features</a>\nout of the box: pattern matching, equality comparison, copying, etc.</p>\n<p>On the other hand, some of these make it harder to implement smart constructors. The implementations also differ\ndepends on which Scala version (and compiler flags) you are using, causing confusion for beginners.</p>\n<p>Let's begin with an initial implementation in <strong>Scala 2.11</strong>:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Email <span class=\"token keyword\">private</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">object</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>With <code class=\"language-inline-text\">final</code>, we disallow attempts to <code class=\"language-inline-text\">extends Email</code>.</li>\n<li>With <code class=\"language-inline-text\">private</code>, construction through <code class=\"language-inline-text\">new Email(value)</code> can only takes place within the current source file.</li>\n</ul>\n<p>However, it is still possible to create an invalid <code class=\"language-inline-text\">Email</code> instance:</p>\n<ul>\n<li>By using <code class=\"language-inline-text\">copy(value = \"badValue\")</code> to create a shallow copy of an instance of <code class=\"language-inline-text\">Email</code> with a bad value.</li>\n<li>By using <code class=\"language-inline-text\">Email(value = \"badValue\")</code>, which translates to calling <code class=\"language-inline-text\">apply()</code> on the <code class=\"language-inline-text\">Email</code>'s companion object to construct an <code class=\"language-inline-text\">Email</code> with a bad value.</li>\n</ul>\n<p>To fix these problems, we need to <strong>either hide or override</strong> the <code class=\"language-inline-text\">copy()</code> and <code class=\"language-inline-text\">apply()</code> functions. For example, with <code class=\"language-inline-text\">apply()</code>, there are 2 choices:</p>\n<ul>\n<li>Override it with <code class=\"language-inline-text\">private</code> modifier to hide the <code class=\"language-inline-text\">apply()</code> function, disallowing construction through <code class=\"language-inline-text\">Email(value)</code>.</li>\n<li>Override it with an alternative return type and implementation: <code class=\"language-inline-text\">Email(value)</code> is possible, but let's say, return <code class=\"language-inline-text\">Option[Email]</code> instead.</li>\n</ul>\n<h3 id=\"211x-and-212x\"><a href=\"#211x-and-212x\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.11.x and 2.12.x</h3>\n<p>It turns out it is not possible to override <code class=\"language-inline-text\">apply()</code> in <strong>vanilla</strong> Scala 2.11.x. See this <a href=\"https://stackoverflow.com/questions/19462598/scala-case-class-implementation-of-smart-constructors\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">StackOverflow question</a> for more details.</p>\n<p>To do that, we need to add the compiler flag <code class=\"language-inline-text\">-Xsource:2.12</code>, which is only available <a href=\"https://github.com/scala/scala/releases/tag/v2.11.11\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">after 2.11.11</a>:</p>\n<blockquote>\n<p>Allow custom apply and unapply methods in case class companions. Also allows case class constructors and apply methods to be private. (In 2.11.11, -Xsource:2.12 is needed to enable these changes. In Scala 2.12.2, they are on by default.)</p>\n</blockquote>\n<p>With this, our code becomes:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Email <span class=\"token keyword\">private</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> copy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Unit</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">object</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Email <span class=\"token operator\">=</span> <span class=\"token operator\">?</span><span class=\"token operator\">?</span><span class=\"token operator\">?</span>\n\n  <span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This is the same for 2.12.x without any compiler flag.</p>\n<h3 id=\"213x-and-dotty\"><a href=\"#213x-and-dotty\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.13.x and Dotty</h3>\n<p>With <strong>vanilla</strong> 2.13.x, the code is the same as 2.12.x. However, <a href=\"https://github.com/scala/scala/releases/tag/v2.13.2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">from 2.13.2</a>, we can reduce the boilerplate by enabling <code class=\"language-inline-text\">-Xsource:3</code>. From <a href=\"https://github.com/scala/scala/pull/7702\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">scala/scala#7702</a>:</p>\n<blockquote>\n<p>Backport from dotty:</p>\n<ul>\n<li>If a case class constructor is private or private[foo]: the synthesized copy and apply methods will have the same access modifier.</li>\n<li>If a case class constructor is protected or protected[foo]: the synthesized copy method will have the same access modifier. The synthesized apply method will remain public, because protected doesn't make sense in an object.\nObviously, if a user defines a custom copy or apply method, that one—including its access modifier—will take precedence.</li>\n</ul>\n</blockquote>\n<p>We end up with the original code that we begin with:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Email <span class=\"token keyword\">private</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">object</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Phew! It only takes a few Scala major releases to get what we want.</p>\n<h2 id=\"the-tricky-one-sealed-abstract-case-class-private\"><a href=\"#the-tricky-one-sealed-abstract-case-class-private\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The Tricky One: <code class=\"language-inline-text\">sealed abstract case class private</code></h2>\n<p>We don't normally see <code class=\"language-inline-text\">abstract</code> being used on a case class. However, for smart constructors, it works wonderfully:</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">sealed</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">case</span> <span class=\"token keyword\">class</span> Email <span class=\"token keyword\">private</span> <span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">object</span> Email <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> fromString<span class=\"token punctuation\">(</span>v<span class=\"token operator\">:</span> <span class=\"token builtin\">String</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Option<span class=\"token punctuation\">[</span>Email<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span>\n    NaiveEmailRegex<span class=\"token punctuation\">.</span>findFirstIn<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>filter<span class=\"token punctuation\">(</span>_ <span class=\"token operator\">==</span> v<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>_ <span class=\"token keyword\">=></span> <span class=\"token keyword\">new</span> Email<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>With <code class=\"language-inline-text\">sealed</code>, we disallow attempts to <code class=\"language-inline-text\">extends Email</code> from outside this source file.</li>\n<li>With <code class=\"language-inline-text\">abstract</code>, we disallow construction through <code class=\"language-inline-text\">new Email()</code>.</li>\n<li>With <code class=\"language-inline-text\">abstract</code>, <code class=\"language-inline-text\">copy()</code> and <code class=\"language-inline-text\">apply()</code> are not automatically generated. We don't have to worry about them.</li>\n<li>It just work™! See <a href=\"https://gist.github.com/tpolecat/a5cb0dc9adeacc93f846835ed21c92d2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the original gist</a> for more details.</li>\n</ul>\n<h2 id=\"testing\"><a href=\"#testing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Testing</h2>\n<p>We verify that our smart constructors implementation works by using a test suite to check that allowed code <strong>Compiles</strong> and the rest <strong>DoesNotCompile</strong>.</p>\n<p>Below is the test suite for <code class=\"language-inline-text\">sealed abstract case class private</code>. The rest can be found in the <a href=\"https://github.com/tuleism/scala-smart-constructors\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">code repository</a>.</p>\n<div class=\"gridsome-highlight\" data-language=\"scala\"><pre class=\"language-scala\"><code class=\"language-scala\"><span class=\"token string\">\"AbstractCaseClassExample\"</span> in <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">import</span> AbstractCaseClassExample<span class=\"token punctuation\">.</span>Email\n  <span class=\"token keyword\">val</span> email <span class=\"token operator\">=</span> Email<span class=\"token punctuation\">.</span>fromString<span class=\"token punctuation\">(</span>exampleEmail<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value <span class=\"token comment\">// apply now return Option</span>\n  email<span class=\"token punctuation\">.</span>value mustBe exampleEmail <span class=\"token comment\">// access ok</span>\n\n  <span class=\"token comment\">// case class's unapply()</span>\n  assertCompiles<span class=\"token punctuation\">(</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n      |email match { case Email(value) => value }\n      |\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// companion's apply()</span>\n  assertDoesNotCompile<span class=\"token punctuation\">(</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n      |Email(exampleEmail)\n      |\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// public constructor</span>\n  assertDoesNotCompile<span class=\"token punctuation\">(</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n      |new Email(exampleEmail)\n      |\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// extends trait</span>\n  assertDoesNotCompile<span class=\"token punctuation\">(</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n      |new Email {\n      |  override def value: String = exampleEmail\n      |}\n      |\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// case class's copy()</span>\n  assertDoesNotCompile<span class=\"token punctuation\">(</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n      |email.copy(value = exampleEmail)\n      |\"\"\"</span><span class=\"token punctuation\">.</span>stripMargin\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"summary\"><a href=\"#summary\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Summary</h2>\n<p>All of these allow us to implement smart constructors. My favorite one is <code class=\"language-inline-text\">sealed abstract case class private</code> because:</p>\n<ul>\n<li>It allows us to use <code class=\"language-inline-text\">case class</code> (instead of <code class=\"language-inline-text\">trait</code>, which is more verbose) and most of its <a href=\"https://docs.scala-lang.org/overviews/scala-book/case-classes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">goodness</a>.</li>\n<li>It looks the same in all Scala version. Cross-building is a breeze.</li>\n</ul>\n","description":"Analyzing various Smart Constructors implementations in Scala.","tags":[{"title":"scala"},{"title":"programming"},{"title":"tricks"}],"headings":[{"value":"Introduction","anchor":"#introduction","depth":2},{"value":"The Straightforward One: sealed trait","anchor":"#the-straightforward-one-sealed-trait","depth":2},{"value":"The Confusing One: final case class private","anchor":"#the-confusing-one-final-case-class-private","depth":2},{"value":"The Tricky One: sealed abstract case class private","anchor":"#the-tricky-one-sealed-abstract-case-class-private","depth":2},{"value":"Testing","anchor":"#testing","depth":2},{"value":"Summary","anchor":"#summary","depth":2}]}},"context":{}}